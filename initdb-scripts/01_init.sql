-- --------------------
-- Tables
-- --------------------
CREATE TABLE IF NOT EXISTS GENDERS (
    id          SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name        VARCHAR(20) UNIQUE NOT NULL
);
CREATE TABLE IF NOT EXISTS PEOPLE (
    pid           SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name          VARCHAR(50) NOT NULL,
    surname       VARCHAR(50) NOT NULL,
    pcode         SMALLINT,
    phone_nr      VARCHAR(15),
    mail          VARCHAR(50),
    is_adult      BOOLEAN,
    gender        SMALLINT,
    country_code  VARCHAR(30),
    description   VARCHAR(50),
    notes         VARCHAR(200),
    when_added    TIMESTAMP NOT NULL,
    UNIQUE NULLS DISTINCT (mail),
    CONSTRAINT fk_gender FOREIGN KEY(gender) REFERENCES GENDERS(id)
);
CREATE TABLE IF NOT EXISTS FAMILIES (
    pid_parent SMALLINT NOT NULL,
    pid_child  SMALLINT NOT NULL,
    CONSTRAINT fk_parent FOREIGN KEY(pid_parent) REFERENCES PEOPLE(pid),
    CONSTRAINT fk_child FOREIGN KEY(pid_child) REFERENCES PEOPLE(pid),
    PRIMARY KEY(pid_parent, pid_child)
);
CREATE TABLE IF NOT EXISTS ROLES (
    rid        SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    role_name  VARCHAR(50) UNIQUE NOT NULL
);
CREATE TABLE IF NOT EXISTS PEOPLE_ROLES (
    rid        SMALLINT NOT NULL,
    pid        SMALLINT NOT NULL,
    CONSTRAINT fk_rid FOREIGN KEY(rid) REFERENCES ROLES(rid),
    CONSTRAINT fk_pid FOREIGN KEY(pid) REFERENCES PEOPLE(pid),
    PRIMARY KEY(rid, pid)
);
CREATE TABLE IF NOT EXISTS PROJECTS (
    prid        SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name        VARCHAR(50) UNIQUE NOT NULL,
    description VARCHAR(200)
);
CREATE TABLE IF NOT EXISTS CATEGORIES (
    id          SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name        VARCHAR(50) UNIQUE NOT NULL
);
CREATE TABLE IF NOT EXISTS GROUPS (
    id          SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name        VARCHAR(50) UNIQUE NOT NULL,
    category_id SMALLINT NOT NULL,
    CONSTRAINT fk_category_id FOREIGN KEY(category_id) REFERENCES CATEGORIES(id)
);
CREATE TABLE IF NOT EXISTS EVENT_TYPES (
    id          SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name        VARCHAR(50) UNIQUE NOT NULL
);
CREATE TABLE IF NOT EXISTS EVENTS (
    id          SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name        VARCHAR(50) UNIQUE NOT NULL,
    date        TIMESTAMP NOT NULL,
    end_date    TIMESTAMP,
    description VARCHAR(2000),
    id_event_type SMALLINT NOT NULL,
    CONSTRAINT fk_type_id FOREIGN KEY(id_event_type) REFERENCES EVENT_TYPES(id)
);
CREATE TABLE IF NOT EXISTS ATENDEES (
    event_id    SMALLINT NOT NULL,
    group_id    SMALLINT NOT NULL,
    no_atendees SMALLINT NOT NULL,
    CONSTRAINT fk_event_id FOREIGN KEY(event_id) REFERENCES EVENTS(id),
    CONSTRAINT fk_group_id FOREIGN KEY(group_id) REFERENCES GROUPS(id),
    CONSTRAINT non_negative_no_attendees CHECK (no_atendees >= 0),
    PRIMARY KEY(event_id, group_id)
);
CREATE TABLE IF NOT EXISTS COURSES (
    id          SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name        VARCHAR(50) UNIQUE NOT NULL,
    teacher_id  SMALLINT,
    description VARCHAR(2000),
    CONSTRAINT fk_teacher_id FOREIGN KEY(teacher_id) REFERENCES PEOPLE(pid)
);
CREATE TABLE IF NOT EXISTS SEMESTERS (
    id          SMALLINT GENERATED BY DEFAULT AS IDENTITY,
    name        VARCHAR(50) NOT NULL,
    course_id   SMALLINT,
    description VARCHAR(2000),
    CONSTRAINT fk_course_id FOREIGN KEY(course_id) REFERENCES COURSES(id) ON DELETE CASCADE,
    PRIMARY KEY(id, course_id)
);
CREATE TABLE IF NOT EXISTS ACTIVITY_TYPES (
    id          SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name        VARCHAR(50) NOT NULL,
    UNIQUE(name)
);
CREATE TABLE IF NOT EXISTS ROLES_ACTIVITY_TYPES (
    rid          SMALLINT NOT NULL,
    atid         SMALLINT NOT NULL,
    CONSTRAINT fk_role_id FOREIGN KEY(rid) REFERENCES ROLES(rid),
    CONSTRAINT fk_activity_type_id FOREIGN KEY(atid) REFERENCES ACTIVITY_TYPES(id),
    PRIMARY KEY(rid, atid)
);
CREATE TABLE IF NOT EXISTS CODES (
    project_id       SMALLINT NOT NULL,
    id               SMALLINT GENERATED BY DEFAULT AS IDENTITY,
    event_type_id    SMALLINT,
    activity_type_id SMALLINT,
    code             VARCHAR(20) NOT NULL,
    additional_checks VARCHAR(2000),
    CONSTRAINT fk_project_id FOREIGN KEY(project_id) REFERENCES PROJECTS(prid),
    CONSTRAINT fk_event_type_id FOREIGN KEY(event_type_id) REFERENCES EVENT_TYPES(id),
    CONSTRAINT fk_activity_type_id FOREIGN KEY(activity_type_id) REFERENCES ACTIVITY_TYPES(id),
    CONSTRAINT event_or_activity_type CHECK (event_type_id IS NOT NULL AND activity_type_id IS NULL OR activity_type_id IS NOT NULL AND event_type_id IS NULL), 
    PRIMARY KEY(project_id, id)
);
CREATE TABLE IF NOT EXISTS SEMESTER_DATES (
    course_id       SMALLINT NOT NULL,
    semester_id     SMALLINT NOT NULL,
    date_id         SMALLINT NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    date            DATE NOT NULL,
    start_time      TIME NOT NULL,
    end_time        TIME NOT NULL,
    CONSTRAINT fk_course_id FOREIGN KEY(course_id, semester_id) REFERENCES SEMESTERS(course_id, id) ON DELETE CASCADE,
    PRIMARY KEY(course_id, semester_id, date_id)
);
CREATE TABLE IF NOT EXISTS ATTENDANCE_TYPES (
    id              SMALLINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name            VARCHAR(20) UNIQUE
);
CREATE TABLE IF NOT EXISTS ATTENDANCE (
    course_id       SMALLINT NOT NULL,
    semester_id     SMALLINT NOT NULL,
    date_id         SMALLINT NOT NULL,
    person_id       SMALLINT NOT NULL,
    attendance_type SMALLINT,
    CONSTRAINT fk_course_id FOREIGN KEY(course_id, semester_id, date_id) REFERENCES SEMESTER_DATES(course_id, semester_id, date_id) ON DELETE CASCADE,
    CONSTRAINT fk_person_id FOREIGN KEY(person_id) REFERENCES PEOPLE(pid) ON DELETE CASCADE,
    CONSTRAINT fk_attendance_type FOREIGN KEY(attendance_type) REFERENCES ATTENDANCE_TYPES(id) ON DELETE CASCADE,
    PRIMARY KEY(course_id, semester_id, date_id, person_id)
);
CREATE TABLE IF NOT EXISTS PEOPLE_SEMESTERS (
    course_id       SMALLINT NOT NULL,
    semester_id     SMALLINT NOT NULL,
    person_id       SMALLINT NOT NULL,
    CONSTRAINT fk_course_id FOREIGN KEY(course_id, semester_id) REFERENCES SEMESTERS(course_id, id) ON DELETE CASCADE,
    CONSTRAINT fk_person_id FOREIGN KEY(person_id) REFERENCES PEOPLE(pid) ON DELETE CASCADE,
    PRIMARY KEY(course_id, semester_id, person_id)
);
CREATE TABLE IF NOT EXISTS ACTIVITIES (
    activity_id         SMALLINT NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    activity_type_id    SMALLINT NOT NULL,
    person_id           SMALLINT NOT NULL,
    date                TIMESTAMP NOT NULL,
    notes               VARCHAR(2000),
    dedicated_time      TIME NOT NULL,
    -- consent_id          SMALLINT,
    course_id           SMALLINT,
    semester_id         SMALLINT,
    CONSTRAINT fk_activity_type_id FOREIGN KEY(activity_type_id) REFERENCES ACTIVITY_TYPES(id) ON DELETE CASCADE,
    CONSTRAINT fk_person_id FOREIGN KEY(person_id) REFERENCES PEOPLE(pid) ON DELETE CASCADE,
    -- CONSTRAINT fk_consent_id FOREIGN KEY(consent_id) REFERENCES CONSENTS(consent_id),
    CONSTRAINT fk_course_id FOREIGN KEY(course_id, semester_id) REFERENCES SEMESTERS(course_id, id),
    CONSTRAINT course_and_semester CHECK(course_id IS NULL AND semester_id IS NULL OR course_id IS NOT NULL AND semester_id IS NOT NULL),
    UNIQUE (activity_id, activity_type_id),
    PRIMARY KEY(activity_id, activity_type_id, person_id)
);
CREATE TABLE IF NOT EXISTS CONSENTS (
    person_id           SMALLINT NOT NULL,
    consent_id          SMALLINT NOT NULL GENERATED BY DEFAULT AS IDENTITY UNIQUE,
    activity_id         SMALLINT,
    activity_type_id    SMALLINT,
    address             VARCHAR(200) NOT NULL,
    notes               VARCHAR(2000),
    CONSTRAINT fk_person_id FOREIGN KEY(person_id) REFERENCES PEOPLE(pid) ON DELETE CASCADE,
    FOREIGN KEY(activity_id, activity_type_id) REFERENCES ACTIVITIES(activity_id, activity_type_id),
    PRIMARY KEY(person_id, consent_id)
);
CREATE TABLE IF NOT EXISTS PEOPLE_EVENTS (
    event_id        SMALLINT NOT NULL,
    person_id       SMALLINT NOT NULL,
    attendance_type SMALLINT, 
    CONSTRAINT fk_event_id FOREIGN KEY(event_id) REFERENCES EVENTS(id) ON DELETE CASCADE,
    CONSTRAINT fk_person_id FOREIGN KEY(person_id) REFERENCES PEOPLE(pid) ON DELETE CASCADE,
    CONSTRAINT fk_attendance_type FOREIGN KEY(attendance_type) REFERENCES ATTENDANCE_TYPES(id) ON DELETE CASCADE,
    PRIMARY KEY(event_id, person_id)
);



-- -------------------- 
-- Views
-- -------------------- 
CREATE OR REPLACE VIEW view_family AS SELECT 0 as dummy, pid_parent, pid_child from FAMILIES;
CREATE OR REPLACE VIEW view_plp_roles AS SELECT 0 as dummy, pid, rid from PEOPLE_ROLES;
CREATE OR REPLACE VIEW view_atendees AS SELECT 0 as dummy, event_id, group_id, no_atendees from ATENDEES;
CREATE OR REPLACE VIEW view_semesters AS 
    SELECT 0 as dummy, id, name, course_id, description from SEMESTERS;
CREATE OR REPLACE VIEW select_atendees AS SELECT c.name as category, g.id as group_id, a.no_atendees, a.event_id
    from ATENDEES a
    INNER JOIN GROUPS g ON a.group_id = g.id
    INNER JOIN CATEGORIES c ON g.category_id = c.id;
CREATE OR REPLACE VIEW view_roles_activity_types AS SELECT 0 as dummy, rid, atid from ROLES_ACTIVITY_TYPES;
CREATE OR REPLACE VIEW view_codes AS SELECT 0 as dummy, project_id, id, event_type_id, activity_type_id, code, additional_checks from CODES;
CREATE OR REPLACE VIEW view_semester_dates AS SELECT 0 as dummy, course_id, semester_id, date_id, date, start_time, end_time from SEMESTER_DATES;
CREATE OR REPLACE VIEW view_attendance AS SELECT 0 as dummy, course_id, semester_id, date_id, person_id, attendance_type from ATTENDANCE;
CREATE OR REPLACE VIEW view_people_semesters AS SELECT 0 as dummy, course_id, semester_id, person_id from PEOPLE_SEMESTERS;
CREATE OR REPLACE VIEW view_activities AS SELECT 0 as dummy, activity_id, activity_type_id, person_id, date, dedicated_time, notes, course_id, semester_id FROM ACTIVITIES;
CREATE OR REPLACE VIEW view_consents AS SELECT 0 as dummy, person_id, consent_id, activity_id, activity_type_id, address, notes FROM CONSENTS;
CREATE OR REPLACE VIEW view_people_events AS SELECT 0 as dummy, event_id, person_id, attendance_type from PEOPLE_EVENTS;


-- -------------------- 
-- Triggers
-- -------------------- 
CREATE OR REPLACE FUNCTION generate_pcode()
-- Generate pcode if there are people with same name & surname
RETURNS TRIGGER
AS $$
DECLARE
    last_pcode SMALLINT;
BEGIN
    IF TG_OP = 'INSERT' OR NEW.name != OLD.name OR NEW.surname != OLD.surname THEN
    SELECT MAX(pcode) FROM people
    INTO last_pcode
    WHERE NEW.name = name AND NEW.surname = surname;

    NEW.pcode = COALESCE(last_pcode + 1, 1);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER pcode_trigger 
    BEFORE INSERT OR UPDATE ON people 
    FOR EACH ROW
    EXECUTE FUNCTION generate_pcode();

CREATE OR REPLACE FUNCTION manage_family_view()
RETURNS TRIGGER
AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO FAMILIES(pid_parent, pid_child) 
        VALUES(NEW.pid_parent, NEW.pid_child);
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM FAMILIES
        WHERE pid_parent = OLD.pid_parent AND pid_child = OLD.pid_child;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER tg_view_family 
    INSTEAD OF INSERT OR DELETE ON view_family 
    FOR EACH ROW
    EXECUTE FUNCTION manage_family_view();

CREATE OR REPLACE FUNCTION manage_plp_roles_view()
RETURNS TRIGGER
AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO PEOPLE_ROLES(rid, pid) 
        VALUES(NEW.rid, NEW.pid);
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM PEOPLE_ROLES
        WHERE pid = OLD.pid AND rid = OLD.rid;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER tg_view_plp_roles
    INSTEAD OF INSERT OR DELETE ON view_plp_roles 
    FOR EACH ROW
    EXECUTE FUNCTION manage_plp_roles_view();

CREATE OR REPLACE FUNCTION manage_atendees_view()
RETURNS TRIGGER
AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO ATENDEES(event_id, group_id, no_atendees) 
        VALUES(NEW.event_id, NEW.group_id, NEW.no_atendees);
    ELSIF TG_OP = 'UPDATE' THEN
        UPDATE ATENDEES
        SET no_atendees = NEW.no_atendees
        WHERE event_id = OLD.event_id AND group_id = OLD.group_id;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM ATENDEES
        WHERE event_id = OLD.event_id AND group_id = OLD.group_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER tg_view_atendees
    INSTEAD OF INSERT OR DELETE ON view_atendees 
    FOR EACH ROW
    EXECUTE FUNCTION manage_atendees_view();

CREATE OR REPLACE FUNCTION manage_semester_view()
RETURNS TRIGGER
AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN 
        INSERT INTO SEMESTERS(name, course_id, description) 
        VALUES(NEW.name, NEW.course_id, NEW.description);
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM SEMESTERS
        WHERE id = OLD.id AND course_id = OLD.course_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER tg_view_semesters 
    INSTEAD OF INSERT OR DELETE ON view_semesters 
    FOR EACH ROW
    EXECUTE FUNCTION manage_semester_view();

CREATE OR REPLACE FUNCTION manage_roles_activity_types_view()
RETURNS TRIGGER
AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN 
        INSERT INTO ROLES_ACTIVITY_TYPES(rid, atid) 
        VALUES(NEW.rid, NEW.atid);
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM ROLES_ACTIVITY_TYPES
        WHERE rid = OLD.rid AND atid = OLD.atid;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER tg_view_roles_activity_types 
    INSTEAD OF INSERT OR DELETE ON view_roles_activity_types 
    FOR EACH ROW
    EXECUTE FUNCTION manage_roles_activity_types_view();

CREATE OR REPLACE FUNCTION manage_codes_view()
RETURNS TRIGGER
AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO CODES(project_id, event_type_id, activity_type_id, code, additional_checks) 
        VALUES(NEW.project_id, NEW.event_type_id, NEW.activity_type_id, NEW.code, NEW.additional_checks);
    ELSIF TG_OP = 'UPDATE' THEN
        UPDATE CODES
        SET event_type_id = NEW.event_type_id,
            activity_type_id = NEW.activity_type_id, 
            code = NEW.code,
            additional_checks = NEW.additional_checks
        WHERE project_id = OLD.project_id AND id = OLD.id;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM CODES
        WHERE project_id = OLD.project_id AND id = OLD.id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER tg_view_codes
    INSTEAD OF INSERT OR DELETE ON view_codes 
    FOR EACH ROW
    EXECUTE FUNCTION manage_codes_view();

CREATE OR REPLACE FUNCTION manage_semester_dates_view()
RETURNS TRIGGER
AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO SEMESTER_DATES(course_id, semester_id, date, start_time, end_time) 
        VALUES(NEW.course_id, NEW.semester_id, NEW.date, NEW.start_time, NEW.end_time);
    ELSIF TG_OP = 'UPDATE' THEN
        UPDATE SEMESTER_DATES
        SET date = NEW.date,
            start_time = NEW.start_time,
            end_time = NEW.end_time
        WHERE course_id = OLD.course_id AND semester_id = OLD.semester_id AND date_id = OLD.date_id;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM SEMESTER_DATES
        WHERE course_id = OLD.course_id AND semester_id = OLD.semester_id AND date_id = OLD.date_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER tg_view_semester_dates
    INSTEAD OF INSERT OR DELETE ON view_semester_dates
    FOR EACH ROW
    EXECUTE FUNCTION manage_semester_dates_view();

CREATE OR REPLACE FUNCTION manage_attendance_view()
RETURNS TRIGGER
AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO ATTENDANCE(course_id, semester_id, date_id, person_id, attendance_type) 
        VALUES(NEW.course_id, NEW.semester_id, NEW.date_id, NEW.person_id, NEW.attendance_type);
    ELSIF TG_OP = 'UPDATE' THEN
        UPDATE ATTENDANCE
        SET attendance_type = NEW.attendance_type
        WHERE course_id = NEW.course_id AND semester_id = NEW.semester_id AND date_id = NEW.date_id AND person_id = NEW.person_id;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM ATTENDANCE
        WHERE course_id = OLD.course_id AND semester_id = OLD.semester_id AND date_id = OLD.date_id AND person_id = OLD.person_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER tg_view_attendance
    INSTEAD OF INSERT OR UPDATE OR DELETE ON view_attendance 
    FOR EACH ROW
    EXECUTE FUNCTION manage_attendance_view();

CREATE OR REPLACE FUNCTION manage_people_semesters_view()
RETURNS TRIGGER
AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO PEOPLE_SEMESTERS(course_id, semester_id, person_id) 
        VALUES(NEW.course_id, NEW.semester_id, NEW.person_id);
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM PEOPLE_SEMESTERS
        WHERE course_id = OLD.course_id AND semester_id = OLD.semester_id AND person_id = OLD.person_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER tg_view_people_semesters
    INSTEAD OF INSERT OR DELETE ON view_people_semesters 
    FOR EACH ROW
    EXECUTE FUNCTION manage_people_semesters_view();

CREATE OR REPLACE FUNCTION generate_attendance()
RETURNS TRIGGER
AS $$
BEGIN
    INSERT INTO ATTENDANCE(course_id, semester_id, date_id, person_id, attendance_type)
    SELECT NEW.course_id, NEW.semester_id, NEW.date_id, person_id, null FROM PEOPLE_SEMESTERS
    WHERE course_id = NEW.course_id AND semester_id = NEW.semester_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER tg_semester_dates
    AFTER INSERT ON SEMESTER_DATES
    FOR EACH ROW
    EXECUTE FUNCTION generate_attendance();

CREATE OR REPLACE FUNCTION manage_activities_view()
RETURNS TRIGGER
AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO ACTIVITIES(activity_type_id, person_id, date, dedicated_time, notes, course_id, semester_id) 
        VALUES(NEW.activity_type_id, NEW.person_id, NEW.date, NEW.dedicated_time, NEW.notes, NEW.course_id, NEW.semester_id);
    ELSIF TG_OP = 'UPDATE' THEN
        UPDATE ACTIVITIES
        SET date = NEW.date, dedicated_time = NEW.dedicated_time, notes = NEW.notes, course_id = NEW.course_id, semester_id = NEW.semester_id, activity_type_id = NEW.activity_type_id
        WHERE activity_id = OLD.activity_id AND activity_type_id = OLD.activity_type_id AND person_id = OLD.person_id;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM ACTIVITIES
        WHERE activity_id = OLD.activity_id AND activity_type_id = OLD.activity_type_id AND person_id = OLD.person_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER tg_view_activities
    INSTEAD OF INSERT OR UPDATE OR DELETE ON view_activities 
    FOR EACH ROW
    EXECUTE FUNCTION manage_activities_view();

CREATE OR REPLACE FUNCTION manage_consents_view()
RETURNS TRIGGER
AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO CONSENTS(person_id, activity_id, activity_type_id, address, notes) 
        VALUES(NEW.person_id, NEW.activity_id, NEW.activity_type_id, NEW.address, NEW.notes);
    ELSIF TG_OP = 'UPDATE' THEN
        UPDATE CONSENTS
        SET address = NEW.address, notes = NEW.notes, activity_id = NEW.activity_id, activity_type_id = NEW.activity_type_id 
        WHERE person_id = OLD.person_id AND consent_id = OLD.consent_id;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM CONSENTS
        WHERE person_id = OLD.person_id AND consent_id = OLD.consent_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER tg_view_consents
    INSTEAD OF INSERT OR UPDATE OR DELETE ON view_consents
    FOR EACH ROW
    EXECUTE FUNCTION manage_consents_view();

CREATE OR REPLACE FUNCTION manage_people_events_view()
RETURNS TRIGGER
AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO PEOPLE_EVENTS(event_id, person_id, attendance_type) 
        VALUES(NEW.event_id, NEW.person_id, NEW.attendance_type);
    ELSIF TG_OP = 'UPDATE' THEN
        UPDATE PEOPLE_EVENTS
        SET attendance_type = NEW.attendance_type 
        WHERE person_id = OLD.person_id AND event_id = OLD.event_id;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM PEOPLE_EVENTS
        WHERE event_id = OLD.event_id AND person_id = OLD.person_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER tg_view_people_events
    INSTEAD OF INSERT OR UPDATE OR DELETE ON view_people_events 
    FOR EACH ROW
    EXECUTE FUNCTION manage_people_events_view();
